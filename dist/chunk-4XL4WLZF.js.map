{"version":3,"sources":["../src/registry.ts","../src/provider.tsx","../src/hooks/useBalance.ts","../src/hooks/useContract.ts","../src/hooks/usePSP22Balances.ts","../src/hooks/useRegisteredContract.ts","../src/hooks/useRegisteredTypedContract.ts"],"names":["accounts","activeExtension","useEffect","useState","contract","typedContract"],"mappings":"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","sourcesContent":["import { SubstrateDeployment } from '@/types'\nimport { Dispatch, SetStateAction } from 'react'\n\n/**\n * Registering the given `deployment` with the given `setDeployments` dispatcher.\n * The registry is kept unique, so if there is already one deployment with\n * equal `contractId` and `networkId` it will be replaced.\n */\nexport const registerDeployment = (\n  setDeployments: Dispatch<SetStateAction<SubstrateDeployment[]>>,\n  deployment: SubstrateDeployment,\n) => {\n  setDeployments((deployments) => {\n    // Check if deployment already exists & remove\n    const idx = deployments.findIndex(\n      ({ contractId, networkId }) =>\n        contractId.toLowerCase() === deployment.contractId.toLowerCase() &&\n        networkId.toLowerCase() === deployment.networkId.toLowerCase(),\n    )\n    if (idx >= 0) deployments.splice(idx, 1)\n\n    // Add new deployment\n    return [...deployments, deployment]\n  })\n}\n\n/**\n * Registers all given `deployments` via `registerDeployment` after awaiting the promise.\n */\nexport const registerDeployments = async (\n  setDeployments: Dispatch<SetStateAction<SubstrateDeployment[]>>,\n  deployments: Promise<SubstrateDeployment[]>,\n) => {\n  ;(await deployments).forEach((deployment) => registerDeployment(setDeployments, deployment))\n}\n","import { accountArraysAreEqual, accountsAreEqual, initPolkadotJs } from '@/helpers'\nimport { registerDeployments } from '@/registry'\nimport {\n  SubstrateChain,\n  SubstrateDeployment,\n  SubstrateWallet,\n  UseInkathonError,\n  UseInkathonErrorCode,\n  UseInkathonProviderContextType,\n} from '@/types'\nimport {\n  allSubstrateWallets,\n  enableWallet,\n  getSubstrateWallet,\n  isWalletInstalled,\n  nightlyConnect,\n} from '@/wallets'\nimport { ApiPromise, HttpProvider, WsProvider } from '@polkadot/api'\nimport { ApiOptions } from '@polkadot/api/types'\nimport { InjectedAccount, InjectedExtension, Unsubcall } from '@polkadot/extension-inject/types'\nimport { Signer } from '@polkadot/types/types'\nimport {\n  FC,\n  PropsWithChildren,\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react'\nimport { getSubstrateChain } from './chains'\nimport { getNightlyConnectAdapter } from './helpers/getNightlyAdapter'\n\nexport const LS_ACTIVE_ACCOUNT_ADDRESS = 'activeAccountAddress'\nexport const LS_ACTIVE_EXTENSION_ID = 'activeExtensionId'\n\nconst UseInkathonProviderContext = createContext<UseInkathonProviderContextType | null>(null)\n\n/**\n * Primary useInkathon hook that exposes `UseInkathonProviderContext`.\n */\nexport const useInkathon = () => {\n  const context = useContext(UseInkathonProviderContext)\n  if (!context) throw new Error('useInkathon must be used within a UseInkathonProvider')\n  return context\n}\n\n/**\n * Main provider that needs to be wrapped around the app (see README)\n * to use `useInkathon` and other hooks anywhere.\n */\nexport interface UseInkathonProviderProps extends PropsWithChildren {\n  appName: string\n  defaultChain: SubstrateChain | SubstrateChain['network']\n  connectOnInit?: boolean\n  deployments?: Promise<SubstrateDeployment[]>\n  apiOptions?: ApiOptions\n  supportedWallets?: SubstrateWallet[]\n}\nexport const UseInkathonProvider: FC<UseInkathonProviderProps> = ({\n  children,\n  appName,\n  defaultChain,\n  connectOnInit,\n  deployments: _deployments,\n  apiOptions,\n  supportedWallets = allSubstrateWallets,\n}) => {\n  // Check if default chain was provided\n  if (\n    !defaultChain ||\n    (typeof defaultChain === 'string' && getSubstrateChain(defaultChain) === undefined)\n  ) {\n    throw new Error(\n      'None or invalid `defaultChain` provided with `UseInkathonProvider`. Forgot to set environment variable?',\n    )\n  }\n\n  // Setup state variables\n  const isInitializing = useRef(false)\n  const isInitialized = useRef(false)\n  const [isConnecting, setIsConnecting] = useState(connectOnInit)\n  const [isConnected, setIsConnected] = useState(false)\n  const [error, setError] = useState<UseInkathonError | undefined>()\n  const [activeChain, setActiveChain] = useState<SubstrateChain>(\n    (typeof defaultChain === 'string'\n      ? getSubstrateChain(defaultChain)\n      : defaultChain) as SubstrateChain,\n  )\n  const [api, setApi] = useState<ApiPromise>()\n  const [provider, setProvider] = useState<WsProvider | HttpProvider>()\n  const [accounts, setAccounts] = useState<InjectedAccount[]>([])\n  const [activeAccount, _setActiveAccount] = useState<InjectedAccount>()\n  const [lastActiveAccount, setLastActiveAccount] = useState<InjectedAccount>()\n  const activeExtension = useRef<InjectedExtension>()\n  const activeSigner = useRef<Signer>()\n  const unsubscribeAccounts = useRef<Unsubcall>()\n  const [deployments, setDeployments] = useState<SubstrateDeployment[]>([])\n\n  // Register given deployments\n  useEffect(() => {\n    if (_deployments) registerDeployments(setDeployments, _deployments)\n  }, [])\n\n  // Initialize polkadot-js/api\n  const initialize = async (chain?: SubstrateChain): Promise<ApiPromise | undefined> => {\n    isInitializing.current = true\n    setIsConnected(false)\n    setError(undefined)\n\n    const _chain = chain || activeChain\n    let _api: ApiPromise | undefined\n    let _provider: WsProvider | HttpProvider | undefined\n    try {\n      ;({ api: _api, provider: _provider } = await initPolkadotJs(_chain, {\n        noInitWarn: true,\n        throwOnConnect: true,\n        ...apiOptions,\n      }))\n\n      api?.disconnect()\n      setApi(_api)\n      provider?.disconnect()\n      setProvider(_provider)\n      isInitialized.current = true\n\n      // Update active chain if switching\n      if (activeChain.network !== _chain.network) setActiveChain(_chain)\n    } catch (e) {\n      const message = 'Error while initializing Polkadot.js API'\n      console.error(message, e)\n      setError({ code: UseInkathonErrorCode.InitializationError, message })\n      setIsConnected(false)\n      setIsConnecting(false)\n      setApi(undefined)\n      setProvider(undefined)\n      isInitialized.current = false\n    }\n\n    isInitializing.current = false\n    return _api\n  }\n\n  // Set active account with local storage persistence\n  const setActiveAccount: React.Dispatch<React.SetStateAction<InjectedAccount | undefined>> = (\n    account,\n  ) => {\n    if (typeof account === 'function') {\n      _setActiveAccount((prevAccount) => {\n        const newAccount = account(prevAccount)\n        if (newAccount) {\n          localStorage.setItem(LS_ACTIVE_ACCOUNT_ADDRESS, newAccount.address)\n        } else {\n          localStorage.removeItem(LS_ACTIVE_ACCOUNT_ADDRESS)\n        }\n        return newAccount\n      })\n    } else {\n      _setActiveAccount(account)\n      if (account) {\n        localStorage.setItem(LS_ACTIVE_ACCOUNT_ADDRESS, account.address)\n      } else {\n        localStorage.removeItem(LS_ACTIVE_ACCOUNT_ADDRESS)\n      }\n    }\n  }\n\n  // Updates account list and active account\n  const updateAccounts = (\n    injectedAccounts: InjectedAccount[],\n    lastActiveAccountAddress?: string,\n  ) => {\n    const newAccounts = injectedAccounts || []\n    // Find active account in new accounts or fallback to latest account\n    const _lastAccount = lastActiveAccountAddress\n      ? { address: lastActiveAccountAddress }\n      : lastActiveAccount\n\n    const newAccount =\n      newAccounts.find((a) => accountsAreEqual(a, _lastAccount)) || newAccounts?.[0]\n\n    // Update accounts and active account\n    if (!accountArraysAreEqual(accounts, newAccounts)) {\n      setAccounts(() => newAccounts)\n    }\n    if (!accountsAreEqual(activeAccount, newAccount)) {\n      setActiveAccount(() => newAccount)\n    }\n    setIsConnected(!!newAccount)\n  }\n  useEffect(() => {\n    if (activeAccount && !accountsAreEqual(activeAccount, lastActiveAccount)) {\n      setLastActiveAccount(() => activeAccount)\n    }\n  }, [activeAccount])\n\n  // Connect to injected wallet\n  const connect = async (\n    chain?: SubstrateChain,\n    wallet?: SubstrateWallet,\n    lastActiveAccountAddress?: string,\n    isInitialConnect?: boolean,\n  ) => {\n    setError(undefined)\n    setIsConnecting(true)\n    setIsConnected(!!activeAccount)\n\n    // Make sure api is initialized & connected to provider\n    if (!api?.isConnected || (chain && chain.network !== activeChain.network)) {\n      const _api = await initialize(chain)\n      if (!_api?.isConnected) return\n    }\n\n    try {\n      // Determine installed wallets\n      const wallets = supportedWallets.filter((w) => {\n        if (!isWalletInstalled(w)) return false\n        // Prevent NightlyConnect to pop up on init when no other wallet is available\n        if (isInitialConnect && w.id === nightlyConnect.id) return false\n        return true\n      })\n      if (!wallets?.length) {\n        const message = 'No Substrate-compatible extension detected'\n        setError({\n          code: UseInkathonErrorCode.NoSubstrateExtensionDetected,\n          message,\n        })\n        throw new Error(message)\n      }\n\n      // Determine wallet to use\n      const preferredWallet = wallet && wallets.find((w) => w.id === wallet.id)\n      const _wallet = preferredWallet || wallets[0]\n\n      // Enable wallet\n      const extension = await enableWallet(_wallet, appName)\n      activeExtension.current = extension\n      localStorage.setItem(LS_ACTIVE_EXTENSION_ID, _wallet.id)\n      activeSigner.current = extension?.signer as Signer\n\n      // Query & keep listening to injected accounts\n      unsubscribeAccounts.current?.()\n      const unsubscribe = extension?.accounts.subscribe((accounts) => {\n        updateAccounts(accounts, lastActiveAccountAddress)\n      })\n      unsubscribeAccounts.current = unsubscribe\n    } catch (e: any) {\n      console.error('Error while connecting wallet:', e)\n      activeExtension.current = undefined\n      activeSigner.current = undefined\n      setIsConnected(false)\n    } finally {\n      setIsConnecting(false)\n    }\n  }\n\n  // Keep active signer up to date\n  useEffect(() => {\n    api?.setSigner(activeSigner.current as Signer)\n  }, [api, activeSigner.current])\n\n  // Disconnect\n  const disconnect = async (disconnectApi?: boolean) => {\n    if (disconnectApi) {\n      await provider?.disconnect()\n      await api?.disconnect()\n      localStorage.removeItem(LS_ACTIVE_EXTENSION_ID)\n      localStorage.removeItem(LS_ACTIVE_ACCOUNT_ADDRESS)\n      return\n    }\n    if (activeExtension.current?.name === nightlyConnect.id) {\n      const adapter = await getNightlyConnectAdapter(appName)\n      await adapter?.disconnect()\n    }\n    setIsConnected(false)\n    updateAccounts([])\n    unsubscribeAccounts.current?.()\n    unsubscribeAccounts.current = undefined\n    activeExtension.current = undefined\n    activeSigner.current = undefined\n    isInitialized.current = false\n  }\n\n  // API Disconnection listener\n  useEffect(() => {\n    if (!api) return\n    const handler = () => {\n      disconnect()\n    }\n    api?.on('disconnected', handler)\n    return () => {\n      api?.off('disconnected', handler)\n    }\n  }, [api])\n\n  // Initialize\n  useEffect(() => {\n    if (isInitialized.current || isInitializing.current) return\n\n    const activeExtensionId = localStorage.getItem(LS_ACTIVE_EXTENSION_ID) || undefined\n    const activeAccountAddress = localStorage.getItem(LS_ACTIVE_ACCOUNT_ADDRESS) || undefined\n    const userWantsConnection = activeExtensionId && activeAccountAddress\n\n    let activeExtension: SubstrateWallet | undefined\n\n    if (activeExtensionId) {\n      activeExtension = allSubstrateWallets.find((w) => w.id === activeExtensionId)\n    }\n\n    connectOnInit || userWantsConnection\n      ? connect(undefined, activeExtension, activeAccountAddress, true)\n      : initialize()\n    return () => {\n      unsubscribeAccounts.current?.()\n    }\n  }, [])\n\n  // Switch active chain\n  const switchActiveChain = async (chain: SubstrateChain) => {\n    const activeWallet = activeExtension.current && getSubstrateWallet(activeExtension.current.name)\n    await connect(chain, activeWallet)\n  }\n\n  return (\n    <UseInkathonProviderContext.Provider\n      value={{\n        isInitializing: isInitializing.current,\n        isInitialized: isInitialized.current,\n        isConnecting,\n        isConnected,\n        error,\n        activeChain,\n        switchActiveChain,\n        api,\n        provider,\n        connect,\n        disconnect,\n        accounts,\n        activeAccount,\n        activeExtension: activeExtension.current,\n        activeSigner: activeSigner.current,\n        setActiveAccount,\n        lastActiveAccount,\n        deployments,\n        supportedWallets,\n      }}\n    >\n      {children}\n    </UseInkathonProviderContext.Provider>\n  )\n}\n","import { BalanceData, BalanceFormatterOptions, getBalance, watchBalance } from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * Hook that returns the native token balance of the given `address`.\n */\nexport const useBalance = (\n  address?: string | AccountId,\n  watch?: boolean,\n  formatterOptions?: BalanceFormatterOptions,\n): BalanceData => {\n  const { api } = useInkathon()\n  const [balanceData, setBalanceData] = useState<BalanceData>({\n    tokenSymbol: 'Unit',\n    tokenDecimals: 12,\n  } satisfies BalanceData)\n  const [unsubscribes, setUnsubscribes] = useState<(VoidFunction | null)[]>([])\n\n  useEffect(() => {\n    const updateBalanceData = (data: BalanceData) => {\n      setBalanceData(() => data)\n    }\n\n    if (!api) {\n      updateBalanceData({} as BalanceData)\n      return\n    }\n\n    if (watch) {\n      watchBalance(api, address, updateBalanceData, formatterOptions).then((unsubscribe) => {\n        setUnsubscribes((prev) => [...prev, unsubscribe])\n      })\n    } else {\n      getBalance(api, address, formatterOptions).then(updateBalanceData)\n    }\n\n    return () => {\n      unsubscribes.forEach((unsubscribe) => unsubscribe?.())\n      setUnsubscribes(() => [])\n    }\n  }, [api, address])\n\n  return balanceData\n}\n","import { useInkathon } from '@/provider'\nimport { Abi, ContractPromise } from '@polkadot/api-contract'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * React Hook that returns a `ContractPromise` object configured with\n * the active api & chain as well as the given `abi` and `address`.\n */\nexport const useContract = (\n  abi?: string | Record<string, unknown> | Abi,\n  address?: string | AccountId,\n) => {\n  const { api, isConnecting } = useInkathon()\n  const [contract, setContract] = useState<ContractPromise | undefined>()\n\n  const initialize = async () => {\n    if (isConnecting || !api || !abi || !address) {\n      setContract(undefined)\n      return\n    }\n    try {\n      const contract = new ContractPromise(api, abi, address)\n      setContract(contract)\n    } catch (error) {\n      console.error('Error during Contract initialization', error)\n    }\n  }\n  useEffect(() => {\n    initialize()\n  }, [api, isConnecting, abi, address])\n\n  return {\n    contract,\n    address,\n  }\n}\n","import {\n  BalanceFormatterOptions,\n  PSP22BalanceData,\n  getPSP22Balances,\n  watchPSP22Balances,\n} from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * Hook that returns the PSP-22 token balances of the given `address`.\n */\nexport const usePSP22Balances = (\n  address?: string | AccountId,\n  watch?: boolean,\n  formatterOptions?: BalanceFormatterOptions,\n): PSP22BalanceData[] => {\n  const { api, activeChain } = useInkathon()\n  const [balanceData, setBalanceData] = useState<PSP22BalanceData[]>(\n    [] satisfies PSP22BalanceData[],\n  )\n  const [unsubscribes, setUnsubscribes] = useState<(VoidFunction | null)[]>([])\n\n  useEffect(() => {\n    const updateBalanceData = (data: PSP22BalanceData[]) => {\n      setBalanceData(() => data)\n    }\n\n    if (!api || !activeChain) {\n      setBalanceData([] as PSP22BalanceData[])\n      return\n    }\n\n    if (watch) {\n      const unsubscribe = watchPSP22Balances(\n        api,\n        address,\n        updateBalanceData,\n        activeChain.network,\n        formatterOptions,\n      )\n      unsubscribe && setUnsubscribes((prev) => [...prev, unsubscribe])\n    } else {\n      getPSP22Balances(api, address, activeChain.network, formatterOptions).then(updateBalanceData)\n    }\n\n    return () => {\n      unsubscribes.forEach((unsubscribe) => unsubscribe?.())\n      setUnsubscribes(() => [])\n    }\n  }, [api, address, activeChain])\n\n  return balanceData\n}\n","import { getDeployment } from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { useContract } from './useContract'\n\n/**\n * React Hook that returns a `ContractPromise` object configured with\n * the active api & chain with the given deployment contract id which\n * is looked up from the deployments registry.\n */\nexport const useRegisteredContract = (contractId: string, networkId?: string) => {\n  const { deployments, activeChain } = useInkathon()\n\n  networkId = networkId || activeChain?.network || ''\n\n  const deployment = getDeployment(deployments || [], contractId, networkId)\n\n  return useContract(deployment?.abi, deployment?.address)\n}\n","import { useRegisteredContract } from '@/hooks/useRegisteredContract'\nimport { useInkathon } from '@/provider'\nimport { TypechainContractConstructor } from '@/types'\nimport { useEffect, useState } from 'react'\n\n/**\n * React Hook that returns a type-safe contract object by `typechain-polkadot`,\n * configured with the active api & chain for the given deployment contract id\n * which is looked up from the deployments registry.\n */\nexport const useRegisteredTypedContract = <T>(\n  contractId: string,\n  Contract: TypechainContractConstructor<T>,\n  networkId?: string,\n) => {\n  const { api, activeAccount } = useInkathon()\n  const registeredContract = useRegisteredContract(contractId, networkId)\n\n  const [typedContract, setTypedContract] = useState<T | undefined>(undefined)\n  useEffect(() => {\n    if (!registeredContract?.address || !activeAccount?.address || !api) {\n      setTypedContract(undefined)\n      return\n    }\n\n    // IMPORTANT: Right now, only KeyringPair is supported as signer, but as we don't have\n    //            those anyways in the frontend, we can alreaday start using the new API.\n    const typedContract = new Contract(\n      registeredContract.address.toString(),\n      activeAccount.address as any,\n      api,\n    )\n    setTypedContract(typedContract)\n  }, [registeredContract?.address, activeAccount?.address])\n\n  return { ...registeredContract, typedContract }\n}\n"]}
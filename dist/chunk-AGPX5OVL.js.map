{"version":3,"sources":["../src/registry.ts","../src/provider.tsx","../src/hooks/useBalance.ts","../src/hooks/useContract.ts","../src/hooks/usePSP22Balances.ts","../src/hooks/useRegisteredContract.ts","../src/hooks/useRegisteredTypedContract.ts"],"names":["registerDeployment","setDeployments","deployment","deployments","idx","contractId","networkId","registerDeployments","__async","createContext","useContext","useEffect","useRef","useState","jsx","UseInkathonProviderContext","useInkathon","context","UseInkathonProvider","children","appName","defaultChain","connectOnInit","_deployments","apiOptions","supportedWallets","allSubstrateWallets","getSubstrateChain","isInitializing","isInitialized","isConnecting","setIsConnecting","isConnected","setIsConnected","error","setError","activeChain","setActiveChain","api","setApi","provider","setProvider","accounts","setAccounts","activeAccount","setActiveAccount","lastActiveAccount","setLastActiveAccount","activeExtension","activeSigner","unsubscribeAccounts","initialize","chain","_chain","_api","_provider","initPolkadotJs","__spreadValues","e","message","updateAccounts","injectedAccounts","lastActiveAccountAddress","newAccounts","_lastAccount","newAccount","a","accountsAreEqual","accountArraysAreEqual","connect","wallet","_a","wallets","isWalletInstalled","_wallet","extension","enableWallet","unsubscribe","disconnect","disconnectApi","_b","nightlyConnect","adapter","getNightlyConnectAdapter","handler","switchActiveChain","activeWallet","getSubstrateWallet","useBalance","address","watch","formatterOptions","balanceData","setBalanceData","unsubscribes","setUnsubscribes","updateBalanceData","data","watchBalance","prev","getBalance","ContractPromise","useContract","abi","contract","setContract","usePSP22Balances","watchPSP22Balances","getPSP22Balances","useRegisteredContract","getDeployment","useRegisteredTypedContract","Contract","registeredContract","typedContract","setTypedContract","__spreadProps"],"mappings":"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","sourcesContent":["import { SubstrateDeployment } from '@/types'\nimport { Dispatch, SetStateAction } from 'react'\n\n/**\n * Registering the given `deployment` with the given `setDeployments` dispatcher.\n * The registry is kept unique, so if there is already one deployment with\n * equal `contractId` and `networkId` it will be replaced.\n */\nexport const registerDeployment = (\n  setDeployments: Dispatch<SetStateAction<SubstrateDeployment[]>>,\n  deployment: SubstrateDeployment,\n) => {\n  setDeployments((deployments) => {\n    // Check if deployment already exists & remove\n    const idx = deployments.findIndex(\n      ({ contractId, networkId }) =>\n        contractId.toLowerCase() === deployment.contractId.toLowerCase() &&\n        networkId.toLowerCase() === deployment.networkId.toLowerCase(),\n    )\n    if (idx >= 0) deployments.splice(idx, 1)\n\n    // Add new deployment\n    return [...deployments, deployment]\n  })\n}\n\n/**\n * Registers all given `deployments` via `registerDeployment` after awaiting the promise.\n */\nexport const registerDeployments = async (\n  setDeployments: Dispatch<SetStateAction<SubstrateDeployment[]>>,\n  deployments: Promise<SubstrateDeployment[]>,\n) => {\n  ;(await deployments).forEach((deployment) => registerDeployment(setDeployments, deployment))\n}\n","import { accountArraysAreEqual, accountsAreEqual, initPolkadotJs } from '@/helpers'\nimport { registerDeployments } from '@/registry'\nimport {\n  SubstrateChain,\n  SubstrateDeployment,\n  SubstrateWallet,\n  UseInkathonError,\n  UseInkathonErrorCode,\n  UseInkathonProviderContextType,\n} from '@/types'\nimport {\n  allSubstrateWallets,\n  enableWallet,\n  getSubstrateWallet,\n  isWalletInstalled,\n  nightlyConnect,\n} from '@/wallets'\nimport { ApiPromise, HttpProvider, WsProvider } from '@polkadot/api'\nimport { ApiOptions } from '@polkadot/api/types'\nimport { InjectedAccount, InjectedExtension, Unsubcall } from '@polkadot/extension-inject/types'\nimport { Signer } from '@polkadot/types/types'\nimport {\n  FC,\n  PropsWithChildren,\n  createContext,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react'\nimport { getSubstrateChain } from './chains'\nimport { getNightlyConnectAdapter } from './helpers/getNightlyAdapter'\n\nconst UseInkathonProviderContext = createContext<UseInkathonProviderContextType | null>(null)\n\n/**\n * Primary useInkathon hook that exposes `UseInkathonProviderContext`.\n */\nexport const useInkathon = () => {\n  const context = useContext(UseInkathonProviderContext)\n  if (!context) throw new Error('useInkathon must be used within a UseInkathonProvider')\n  return context\n}\n\n/**\n * Main provider that needs to be wrapped around the app (see README)\n * to use `useInkathon` and other hooks anywhere.\n */\nexport interface UseInkathonProviderProps extends PropsWithChildren {\n  appName: string\n  defaultChain: SubstrateChain | SubstrateChain['network']\n  connectOnInit?: boolean\n  deployments?: Promise<SubstrateDeployment[]>\n  apiOptions?: ApiOptions\n  supportedWallets?: SubstrateWallet[]\n}\nexport const UseInkathonProvider: FC<UseInkathonProviderProps> = ({\n  children,\n  appName,\n  defaultChain,\n  connectOnInit,\n  deployments: _deployments,\n  apiOptions,\n  supportedWallets = allSubstrateWallets,\n}) => {\n  // Check if default chain was provided\n  if (\n    !defaultChain ||\n    (typeof defaultChain === 'string' && getSubstrateChain(defaultChain) === undefined)\n  ) {\n    throw new Error(\n      'None or invalid `defaultChain` provided with `UseInkathonProvider`. Forgot to set environment variable?',\n    )\n  }\n\n  // Setup state variables\n  const isInitializing = useRef(false)\n  const isInitialized = useRef(false)\n  const [isConnecting, setIsConnecting] = useState(connectOnInit)\n  const [isConnected, setIsConnected] = useState(false)\n  const [error, setError] = useState<UseInkathonError | undefined>()\n  const [activeChain, setActiveChain] = useState<SubstrateChain>(\n    (typeof defaultChain === 'string'\n      ? getSubstrateChain(defaultChain)\n      : defaultChain) as SubstrateChain,\n  )\n  const [api, setApi] = useState<ApiPromise>()\n  const [provider, setProvider] = useState<WsProvider | HttpProvider>()\n  const [accounts, setAccounts] = useState<InjectedAccount[]>([])\n  const [activeAccount, setActiveAccount] = useState<InjectedAccount>()\n  const [lastActiveAccount, setLastActiveAccount] = useState<InjectedAccount>()\n  const activeExtension = useRef<InjectedExtension>()\n  const activeSigner = useRef<Signer>()\n  const unsubscribeAccounts = useRef<Unsubcall>()\n  const [deployments, setDeployments] = useState<SubstrateDeployment[]>([])\n\n  // Register given deployments\n  useEffect(() => {\n    if (_deployments) registerDeployments(setDeployments, _deployments)\n  }, [])\n\n  // Initialize polkadot-js/api\n  const initialize = async (chain?: SubstrateChain): Promise<ApiPromise | undefined> => {\n    isInitializing.current = true\n    setIsConnected(false)\n    setError(undefined)\n\n    const _chain = chain || activeChain\n    let _api: ApiPromise | undefined\n    let _provider: WsProvider | HttpProvider | undefined\n    try {\n      ;({ api: _api, provider: _provider } = await initPolkadotJs(_chain, {\n        noInitWarn: true,\n        throwOnConnect: true,\n        ...apiOptions,\n      }))\n\n      api?.disconnect()\n      setApi(_api)\n      provider?.disconnect()\n      setProvider(_provider)\n      isInitialized.current = true\n\n      // Update active chain if switching\n      if (activeChain.network !== _chain.network) setActiveChain(_chain)\n    } catch (e) {\n      const message = 'Error while initializing Polkadot.js API'\n      console.error(message, e)\n      setError({ code: UseInkathonErrorCode.InitializationError, message })\n      setIsConnected(false)\n      setIsConnecting(false)\n      setApi(undefined)\n      setProvider(undefined)\n      isInitialized.current = false\n    }\n\n    isInitializing.current = false\n    return _api\n  }\n\n  // Updates account list and active account\n  const updateAccounts = (\n    injectedAccounts: InjectedAccount[],\n    lastActiveAccountAddress?: string,\n  ) => {\n    const newAccounts = injectedAccounts || []\n    // Find active account in new accounts or fallback to latest account\n    const _lastAccount = lastActiveAccountAddress\n      ? { address: lastActiveAccountAddress }\n      : lastActiveAccount\n    const newAccount =\n      newAccounts.find((a) => accountsAreEqual(a, _lastAccount)) || newAccounts?.[0]\n\n    // Update accounts and active account\n    if (!accountArraysAreEqual(accounts, newAccounts)) {\n      setAccounts(() => newAccounts)\n    }\n    if (!accountsAreEqual(activeAccount, newAccount)) {\n      setActiveAccount(() => newAccount)\n    }\n    setIsConnected(!!newAccount)\n  }\n  useEffect(() => {\n    if (activeAccount && !accountsAreEqual(activeAccount, lastActiveAccount)) {\n      setLastActiveAccount(() => activeAccount)\n    }\n  }, [activeAccount])\n\n  // Connect to injected wallet\n  const connect = async (\n    chain?: SubstrateChain,\n    wallet?: SubstrateWallet,\n    lastActiveAccountAddress?: string,\n  ) => {\n    setError(undefined)\n    setIsConnecting(true)\n    setIsConnected(!!activeAccount)\n\n    // Make sure api is initialized & connected to provider\n    if (!api?.isConnected || (chain && chain.network !== activeChain.network)) {\n      const _api = await initialize(chain)\n      if (!_api?.isConnected) return\n    }\n\n    try {\n      // Determine installed wallets\n      const wallets = supportedWallets.filter((w) => isWalletInstalled(w))\n      if (!wallets?.length) {\n        const message = 'No Substrate-compatible extension detected'\n        setError({\n          code: UseInkathonErrorCode.NoSubstrateExtensionDetected,\n          message,\n        })\n        throw new Error(message)\n      }\n\n      // Determine wallet to use\n      const preferredWallet = wallet && wallets.find((w) => w.id === wallet.id)\n      const _wallet = preferredWallet || wallets[0]\n\n      // Enable wallet\n      const extension = await enableWallet(_wallet, appName)\n      activeExtension.current = extension\n      activeSigner.current = extension?.signer as Signer\n\n      // Query & keep listening to injected accounts\n      unsubscribeAccounts.current?.()\n      const unsubscribe = extension?.accounts.subscribe((accounts) => {\n        updateAccounts(accounts, lastActiveAccountAddress)\n      })\n      unsubscribeAccounts.current = unsubscribe\n    } catch (e: any) {\n      console.error('Error while connecting wallet:', e)\n      activeExtension.current = undefined\n      activeSigner.current = undefined\n      setIsConnected(false)\n    } finally {\n      setIsConnecting(false)\n    }\n  }\n\n  // Keep active signer up to date\n  useEffect(() => {\n    api?.setSigner(activeSigner.current as Signer)\n  }, [api, activeSigner.current])\n\n  // Disconnect\n  const disconnect = async (disconnectApi?: boolean) => {\n    if (disconnectApi) {\n      await provider?.disconnect()\n      await api?.disconnect()\n      return\n    }\n    if (activeExtension.current?.name === nightlyConnect.id) {\n      const adapter = await getNightlyConnectAdapter(appName)\n      await adapter?.disconnect()\n    }\n    setIsConnected(false)\n    updateAccounts([])\n    unsubscribeAccounts.current?.()\n    unsubscribeAccounts.current = undefined\n    activeExtension.current = undefined\n    activeSigner.current = undefined\n    isInitialized.current = false\n  }\n\n  // API Disconnection listener\n  useEffect(() => {\n    if (!api) return\n    const handler = () => {\n      disconnect()\n    }\n    api?.on('disconnected', handler)\n    return () => {\n      api?.off('disconnected', handler)\n    }\n  }, [api])\n\n  // Initialize\n  useEffect(() => {\n    if (isInitialized.current || isInitializing.current) return\n    connectOnInit ? connect() : initialize()\n    return () => {\n      unsubscribeAccounts.current?.()\n    }\n  }, [])\n\n  // Switch active chain\n  const switchActiveChain = async (chain: SubstrateChain) => {\n    const activeWallet = activeExtension.current && getSubstrateWallet(activeExtension.current.name)\n    await connect(chain, activeWallet)\n  }\n\n  return (\n    <UseInkathonProviderContext.Provider\n      value={{\n        isInitializing: isInitializing.current,\n        isInitialized: isInitialized.current,\n        isConnecting,\n        isConnected,\n        error,\n        activeChain,\n        switchActiveChain,\n        api,\n        provider,\n        connect,\n        disconnect,\n        accounts,\n        activeAccount,\n        activeExtension: activeExtension.current,\n        activeSigner: activeSigner.current,\n        setActiveAccount,\n        lastActiveAccount,\n        deployments,\n        supportedWallets,\n      }}\n    >\n      {children}\n    </UseInkathonProviderContext.Provider>\n  )\n}\n","import { BalanceData, BalanceFormatterOptions, getBalance, watchBalance } from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * Hook that returns the native token balance of the given `address`.\n */\nexport const useBalance = (\n  address?: string | AccountId,\n  watch?: boolean,\n  formatterOptions?: BalanceFormatterOptions,\n): BalanceData => {\n  const { api } = useInkathon()\n  const [balanceData, setBalanceData] = useState<BalanceData>({\n    tokenSymbol: 'Unit',\n    tokenDecimals: 12,\n  } satisfies BalanceData)\n  const [unsubscribes, setUnsubscribes] = useState<(VoidFunction | null)[]>([])\n\n  useEffect(() => {\n    const updateBalanceData = (data: BalanceData) => {\n      setBalanceData(() => data)\n    }\n\n    if (!api) {\n      updateBalanceData({} as BalanceData)\n      return\n    }\n\n    if (watch) {\n      watchBalance(api, address, updateBalanceData, formatterOptions).then((unsubscribe) => {\n        setUnsubscribes((prev) => [...prev, unsubscribe])\n      })\n    } else {\n      getBalance(api, address, formatterOptions).then(updateBalanceData)\n    }\n\n    return () => {\n      unsubscribes.forEach((unsubscribe) => unsubscribe?.())\n      setUnsubscribes(() => [])\n    }\n  }, [api, address])\n\n  return balanceData\n}\n","import { useInkathon } from '@/provider'\nimport { Abi, ContractPromise } from '@polkadot/api-contract'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * React Hook that returns a `ContractPromise` object configured with\n * the active api & chain as well as the given `abi` and `address`.\n */\nexport const useContract = (\n  abi?: string | Record<string, unknown> | Abi,\n  address?: string | AccountId,\n) => {\n  const { api, isConnecting } = useInkathon()\n  const [contract, setContract] = useState<ContractPromise | undefined>()\n\n  const initialize = async () => {\n    if (isConnecting || !api || !abi || !address) {\n      setContract(undefined)\n      return\n    }\n    try {\n      const contract = new ContractPromise(api, abi, address)\n      setContract(contract)\n    } catch (error) {\n      console.error('Error during Contract initialization', error)\n    }\n  }\n  useEffect(() => {\n    initialize()\n  }, [api, isConnecting, abi, address])\n\n  return {\n    contract,\n    address,\n  }\n}\n","import {\n  BalanceFormatterOptions,\n  PSP22BalanceData,\n  getPSP22Balances,\n  watchPSP22Balances,\n} from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { AccountId } from '@polkadot/types/interfaces'\nimport { useEffect, useState } from 'react'\n\n/**\n * Hook that returns the PSP-22 token balances of the given `address`.\n */\nexport const usePSP22Balances = (\n  address?: string | AccountId,\n  watch?: boolean,\n  formatterOptions?: BalanceFormatterOptions,\n): PSP22BalanceData[] => {\n  const { api, activeChain } = useInkathon()\n  const [balanceData, setBalanceData] = useState<PSP22BalanceData[]>(\n    [] satisfies PSP22BalanceData[],\n  )\n  const [unsubscribes, setUnsubscribes] = useState<(VoidFunction | null)[]>([])\n\n  useEffect(() => {\n    const updateBalanceData = (data: PSP22BalanceData[]) => {\n      setBalanceData(() => data)\n    }\n\n    if (!api || !activeChain) {\n      setBalanceData([] as PSP22BalanceData[])\n      return\n    }\n\n    if (watch) {\n      const unsubscribe = watchPSP22Balances(\n        api,\n        address,\n        updateBalanceData,\n        activeChain.network,\n        formatterOptions,\n      )\n      unsubscribe && setUnsubscribes((prev) => [...prev, unsubscribe])\n    } else {\n      getPSP22Balances(api, address, activeChain.network, formatterOptions).then(updateBalanceData)\n    }\n\n    return () => {\n      unsubscribes.forEach((unsubscribe) => unsubscribe?.())\n      setUnsubscribes(() => [])\n    }\n  }, [api, address, activeChain])\n\n  return balanceData\n}\n","import { getDeployment } from '@/helpers'\nimport { useInkathon } from '@/provider'\nimport { useContract } from './useContract'\n\n/**\n * React Hook that returns a `ContractPromise` object configured with\n * the active api & chain with the given deployment contract id which\n * is looked up from the deployments registry.\n */\nexport const useRegisteredContract = (contractId: string, networkId?: string) => {\n  const { deployments, activeChain } = useInkathon()\n\n  networkId = networkId || activeChain?.network || ''\n\n  const deployment = getDeployment(deployments || [], contractId, networkId)\n\n  return useContract(deployment?.abi, deployment?.address)\n}\n","import { useRegisteredContract } from '@/hooks/useRegisteredContract'\nimport { useInkathon } from '@/provider'\nimport { TypechainContractConstructor } from '@/types'\nimport { useEffect, useState } from 'react'\n\n/**\n * React Hook that returns a type-safe contract object by `typechain-polkadot`,\n * configured with the active api & chain for the given deployment contract id\n * which is looked up from the deployments registry.\n */\nexport const useRegisteredTypedContract = <T>(\n  contractId: string,\n  Contract: TypechainContractConstructor<T>,\n  networkId?: string,\n) => {\n  const { api, activeAccount } = useInkathon()\n  const registeredContract = useRegisteredContract(contractId, networkId)\n\n  const [typedContract, setTypedContract] = useState<T | undefined>(undefined)\n  useEffect(() => {\n    if (!registeredContract?.address || !activeAccount?.address || !api) {\n      setTypedContract(undefined)\n      return\n    }\n\n    // IMPORTANT: Right now, only KeyringPair is supported as signer, but as we don't have\n    //            those anyways in the frontend, we can alreaday start using the new API.\n    const typedContract = new Contract(\n      registeredContract.address.toString(),\n      activeAccount.address as any,\n      api,\n    )\n    setTypedContract(typedContract)\n  }, [registeredContract?.address, activeAccount?.address])\n\n  return { ...registeredContract, typedContract }\n}\n"]}